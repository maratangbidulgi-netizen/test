<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>Tetris Full Grid</title>
<style>
body {
  background:#111;
  color:white;
  display:flex;
  justify-content:center;
  margin-top:30px;
  font-family:Arial, sans-serif;
}
.container {
  display:flex;
  gap:20px;
}
canvas {
  border:3px solid white;
  background:black;
}
.info {
  font-size:18px;
}
</style>
</head>

<body>
<div class="container">
  <canvas id="tetris" width="240" height="400"></canvas>
  <div class="info">
    <p>점수: <span id="score">0</span></p>
    <p>R : 재시작</p>
    <p>← → 이동</p>
    <p>↑ 회전</p>
    <p>↓ 소프트 드롭</p>
    <p>Space 하드 드롭</p>
  </div>
</div>

<script>
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
ctx.scale(20,20);

const scoreEl = document.getElementById('score');

const textures = [
  null,
  ['#ff5f9e','#ff0d72'],
  ['#4fd3ff','#0dc2ff'],
  ['#4fff9a','#0dff72'],
  ['#d96bff','#f538ff'],
  ['#ffb05f','#ff8e0d'],
  ['#fff18f','#ffe138'],
  ['#6b8cff','#3877ff']
];

function createMatrix(w,h){
  return Array.from({length:h},()=>Array(w).fill(0));
}

function createPiece(type){
  if(type==='T')return[[0,0,0],[1,1,1],[0,1,0]];
  if(type==='O')return[[2,2],[2,2]];
  if(type==='L')return[[0,3,0],[0,3,0],[0,3,3]];
  if(type==='J')return[[0,4,0],[0,4,0],[4,4,0]];
  if(type==='I')return[[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
  if(type==='S')return[[0,6,6],[6,6,0],[0,0,0]];
  if(type==='Z')return[[7,7,0],[0,7,7],[0,0,0]];
}

const arena = createMatrix(12,20);

const player = {
  pos:{x:0,y:0},
  matrix:null,
  score:0
};

let dropInterval = 500;
const MAX_SPEED = 100;

function resetGame(){
  arena.forEach(r=>r.fill(0));
  player.score = 0;
  dropInterval = 500;
  updateScore();
  playerReset();
}

function collide(arena,player){
  const m = player.matrix;
  const o = player.pos;
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if(
        m[y][x]!==0 &&
        (arena[y+o.y]?.[x+o.x] ?? 1)!==0
      ){
        return true;
      }
    }
  }
  return false;
}

function merge(arena,player){
  player.matrix.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v!==0){
        arena[y+player.pos.y][x+player.pos.x]=v;
      }
    });
  });
}

function rotate(matrix){
  for(let y=0;y<matrix.length;y++){
    for(let x=0;x<y;x++){
      [matrix[x][y],matrix[y][x]] =
      [matrix[y][x],matrix[x][y]];
    }
  }
  matrix.forEach(r=>r.reverse());
}

function playerRotate(){
  const pos = player.pos.x;
  let offset = 1;
  rotate(player.matrix);
  while(collide(arena,player)){
    player.pos.x += offset;
    offset = -(offset+(offset>0?1:-1));
    if(offset>player.matrix[0].length){
      rotate(player.matrix);
      rotate(player.matrix);
      rotate(player.matrix);
      player.pos.x = pos;
      return;
    }
  }
}

function arenaSweep(){
  let lines = 0;
  outer:for(let y=arena.length-1;y>=0;y--){
    for(let x=0;x<arena[y].length;x++){
      if(arena[y][x]===0)continue outer;
    }
    arena.splice(y,1);
    arena.unshift(new Array(arena[0].length).fill(0));
    lines++;
    y++;
  }

  if(lines>0){
    player.score += lines*10;
    dropInterval = Math.max(
      MAX_SPEED,
      500 - Math.floor(player.score/10)*40
    );
    updateScore();
  }
}

function playerDrop(){
  player.pos.y++;
  if(collide(arena,player)){
    player.pos.y--;
    merge(arena,player);
    arenaSweep();
    playerReset();
  }
}

function playerMove(dir){
  player.pos.x += dir;
  if(collide(arena,player))player.pos.x -= dir;
}

function playerReset(){
  const pieces='TJLOSZI';
  player.matrix = createPiece(
    pieces[Math.random()*pieces.length|0]
  );
  player.pos.y = 0;
  player.pos.x =
    (arena[0].length/2|0) -
    (player.matrix[0].length/2|0);

  if(collide(arena,player)){
    alert('게임 오버');
    resetGame();
  }
}

/* ===== 전체 화면 그리드 (오버레이) ===== */
function drawGrid(){
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 0.03;

  for(let x=0;x<=12;x++){
    ctx.beginPath();
    ctx.moveTo(x,0);
    ctx.lineTo(x,20);
    ctx.stroke();
  }

  for(let y=0;y<=20;y++){
    ctx.beginPath();
    ctx.moveTo(0,y);
    ctx.lineTo(12,y);
    ctx.stroke();
  }
}

function drawMatrix(matrix,offset){
  matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value!==0){
        const g = ctx.createLinearGradient(
          x+offset.x, y+offset.y,
          x+offset.x+1, y+offset.y+1
        );
        g.addColorStop(0,textures[value][0]);
        g.addColorStop(1,textures[value][1]);
        ctx.fillStyle = g;
        ctx.fillRect(
          x+offset.x,
          y+offset.y,
          1,1
        );
      }
    });
  });
}

function draw(){
  ctx.fillStyle='#000';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  drawMatrix(arena,{x:0,y:0});
  drawMatrix(player.matrix,player.pos);

  drawGrid(); // ← 항상 맨 마지막 (전체 오버레이)
}

function updateScore(){
  scoreEl.textContent = player.score;
}

let dropCounter = 0;
let lastTime = 0;

function update(time=0){
  const delta = time-lastTime;
  lastTime = time;
  dropCounter += delta;
  if(dropCounter>dropInterval){
    playerDrop();
    dropCounter = 0;
  }
  draw();
  requestAnimationFrame(update);
}

document.addEventListener('keydown',e=>{
  if(e.key==='ArrowLeft')playerMove(-1);
  if(e.key==='ArrowRight')playerMove(1);
  if(e.key==='ArrowDown')playerDrop();
  if(e.key==='ArrowUp')playerRotate();
  if(e.code==='Space'){
    while(!collide(arena,player))player.pos.y++;
    player.pos.y--;
    merge(arena,player);
    arenaSweep();
    playerReset();
  }
  if(e.key==='r'||e.key==='R'){
    resetGame();
  }
});

resetGame();
update();
</script>
</body>
</html>
